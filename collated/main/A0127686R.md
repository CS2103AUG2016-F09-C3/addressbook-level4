# A0127686R
###### /java/seedu/flexitrack/logic/commands/AddCommand.java
``` java
    @Override
    public void executeUndo() {
        Task toDelete = toAdd;

        try {
            model.deleteTask(toDelete);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }
    }

    @Override
    int getNumOfOccurrrence() {
        return numOfOccurrrence;
    }
    
    @Override
    void setNumOfOccurrrence(int numOfOccurrrence) {
        this.numOfOccurrrence = numOfOccurrrence;
    }
}
```
###### /java/seedu/flexitrack/logic/commands/Command.java
``` java
    /**
     * Record the command to perform undo 
     * 
     * @param command
     */
    public void recordCommand(Command command){
        UndoCommand.doneCommandStack.add(command); 
    }
    
    int getNumOfOccurrrence(){
        return 0; 
    }

    void setNumOfOccurrrence(int numOfOccurrrence) {
        assert numOfOccurrrence != 0;
    }
}
```
###### /java/seedu/flexitrack/logic/commands/EditCommand.java
``` java
    @Override
    public void executeUndo() {
        Task toDelete = editedTask; 
        Task toAddBack = taskStore;

        try {
            model.deleteTask(toDelete);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }
        
        try {
            model.addTask(toAddBack);
        } catch (DuplicateTaskException e) {
            indicateAttemptToExecuteIncorrectCommand();
        }
    }
}
```
###### /java/seedu/flexitrack/logic/commands/GapCommand.java
``` java
package seedu.flexitrack.logic.commands;

import java.util.List;

import seedu.flexitrack.model.task.DateTimeInfo;

/**
 * Find a gap with minimum time specified by the user. 
 */
public class GapCommand extends Command {

    public static final String COMMAND_WORD = "gap";
    public static final String COMMAND_SHORTCUT = "g";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ", shortcut [" + COMMAND_SHORTCUT + "]" + 
            ": Find the earliest specified timing available.\n" 
            + "1. To find a gap with default number of gap searched (3) - Parameters: [specified timing] \n"
            + "   Example: " + COMMAND_WORD + " 3 hours \n"
            + "2. To find a specific number of gap - Parameters: [specified timing] n/[number of gap to find] \n"
            + "   Example: " + COMMAND_WORD + " 30 minutes n/4\n"
            + "Note that :\n"
            + "   1. The specified timing and number of gap need to be in digit.\n"
            + "   2. Timing for minutes can't be longer than 59 minutes, for hour it can't be longer than 23 hours"
            + "and for days it can't be more than 29 days\n"
            + "Example of accepted specified timing: 20m, 30 minutes, 2 hours, 12 h, 2 days.\n"
            + "Example of rejected specified timing: 70 minutes, 2 hours 30 minutes";
            
    public static final String MESSAGE_SUCCESS = "The earliest %1$s free time are found... ";
    public static final String WORD_DAY = "day";
    public static final String WORD_HOUR = "hour";
    public static final String WORD_MINUTE = "minute";
    public static final String INITIAL_DAY = "d";
    public static final String INITIAL_HOUR = "h";
    public static final String INITIAL_MINUTE = "m";
    public static final int DEFAULT_NUMBER_OF_SLOT = 3;
    public static final int REF_NO_DAY = 2;
    public static final int REF_NO_HOUR = 1;
    public static final int REF_NO_MINUTE = 0;

    private final int keyword;
    private final int length; 
    private final int numberOfSlot; 

    public GapCommand(int keyword, int length, int numberOfSlot) {
        this.keyword = keyword;
        this.length = length;
        this.numberOfSlot = numberOfSlot;
    }

    @Override
    public CommandResult execute() {
        List<DateTimeInfo> listOfTiming = model.findSpecifiedGapTiming(keyword, length, numberOfSlot);
        String theListOfDates = putResultIntoString(listOfTiming);
        String keywordString = putKeywordIntoString();
        return new CommandResult((String.format(MESSAGE_SUCCESS, keywordString) + theListOfDates));
    }

    /**
     * Put the user specified timing back into string
     * 
     * @return the specified timing by the users
     */
    private String putKeywordIntoString() {
        String keywordString = "";
        switch (keyword) {
        case 0:
            keywordString = "minute";
            break;
        case 1:
            keywordString = "hour";
            break;
        case 2:
            keywordString = "day";
            break;
        }
        keywordString = length + " " + keywordString;
        if (length > 1) {
            keywordString = keywordString + "s";
        }
        return keywordString;
    }

    /**
     * Rearrange and put into String the starting and ending time of the gap 
     * @param listOfTiming
     * @return The timing of the gap in string, ready to be shown to the user 
     */
    private String putResultIntoString(List<DateTimeInfo> listOfTiming) {
        String theListOfDates = "";
        int iter = 0;
        for (; iter < listOfTiming.size() - 1; iter++) {
            if (iter == 0 && listOfTiming.get(iter).toString().equals(DateTimeInfo.getCurrentTime().toString())) {
                theListOfDates = theListOfDates + "\nBetween:  now                        ";
            } else {
                theListOfDates = theListOfDates + "\nBetween:  " + listOfTiming.get(iter).toString();
            }
            iter = iter + 1;
            theListOfDates = theListOfDates + "  to: " + listOfTiming.get(iter).toString();

        }
        if ((iter + 1) / 2 < numberOfSlot) {
            theListOfDates = theListOfDates + "\nFree from: " + listOfTiming.get(iter).toString() + " onwards. ";
        }
        return theListOfDates;
    }

}
```
###### /java/seedu/flexitrack/logic/commands/ListCommand.java
``` java
package seedu.flexitrack.logic.commands;

/**
 * Lists all task in the FlexiTrack to the user.
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = "list";
    public static final String COMMAND_SHORTCUT = "l";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ", Shortcut [" + COMMAND_SHORTCUT + "]" + 
            ": List all the to do lists in FlexiTrack.\n" 
            + COMMAND_WORD + " future : List all the to do lists that is due or start in the future.\n"
            + COMMAND_WORD + " past : List all the to do lists in the past.\n"
            + COMMAND_WORD + " mark: List all the to do lists that has been marked.\n"
            + COMMAND_WORD + " unmark: List all the to do lists in that has not been marked.\n"
            + "Example: " + COMMAND_WORD + " past \n";
    public static final String MESSAGE_SUCCESS = "Listed all tasks";
    public static final String LIST_FUTURE_COMMAND = "future";
    public static final String LIST_PAST_COMMAND = "past";
    public static final String LIST_MARK_COMMAND = "mark";
    public static final String LIST_UNMARK_COMMAND = "unmark";
    public static final String LIST_BLOCK_COMMAND = "block";
    public static final String LIST_LAST_COMMAND = "last";
    public static final String LIST_NEXT_COMMAND = "next";
    public static final String LIST_LAST_WEEK_COMMAND = "last week";
    public static final String LIST_LAST_MONTH_COMMAND = "last month";
    public static final String LIST_NEXT_WEEK_COMMAND = "next week";
    public static final String LIST_NEXT_MONTH_COMMAND = "next month";
    public static final String LIST_UNSPECIFIED_COMMAND = "";

    public final String arguments;

    public ListCommand(String args) {
        this.arguments = args;
    }

    @Override
    public CommandResult execute() {
        if (arguments.equals(LIST_UNSPECIFIED_COMMAND)) {
            model.updateFilteredListToShowAll();
        } else {
            model.updateFilteredListToFitUserInput(arguments);
        }
        return new CommandResult(MESSAGE_SUCCESS);
    }

}
```
###### /java/seedu/flexitrack/logic/commands/MarkCommand.java
``` java
    @Override
    public void executeUndo() {
        Task toDelete = markedTask;
        Task toAddBack = taskStore;

        try {
            model.deleteTask(toDelete);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }

        try {
            model.addTask(toAddBack);
        } catch (DuplicateTaskException e) {
            indicateAttemptToExecuteIncorrectCommand();
        }
    }
}
```
###### /java/seedu/flexitrack/logic/commands/UndoCommand.java
``` java
package seedu.flexitrack.logic.commands;

import java.util.Stack;

import seedu.flexitrack.model.task.ReadOnlyTask;

/**
 * Clears the FlexiTrack.
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";
    public static final String COMMAND_SHORTCUT = "ud"; // TODO: impiment ctrl + Z
    public static final String MESSAGE_USAGE = COMMAND_WORD + ", Shortcut [" + COMMAND_SHORTCUT + "]"
            + ": Clear the to do lists in FlexiTrack.\n" + "Example: " + COMMAND_WORD;
    public static final String MESSAGE_SUCCESS = "Your last command has been undone!";
    public static final String MESSAGE_NOT_SUCCESS = "You have no command to undo!";

    // Stores all the commands done from app launch
    static Stack<Command> doneCommandStack = new Stack<Command>();

    public UndoCommand() {
    }

    @Override
    public CommandResult execute() {
        Command undo = null;

        if (doneCommandStack.size() == 0) {
            return new CommandResult(String.format(MESSAGE_NOT_SUCCESS));
        }

        
        undo = doneCommandStack.pop();
        if (undo instanceof AddCommand && undo.getNumOfOccurrrence() !=0 ){
            int numOfOccurrrence = undo.getNumOfOccurrrence();
            undo.setNumOfOccurrrence(0);
            for (int i = 1; i < numOfOccurrrence; i++) {
                undo.executeUndo();
                RedoCommand.undoneCommandStack.push(undo);
                undo = doneCommandStack.pop();
            }
            undo.setNumOfOccurrrence(numOfOccurrrence);
        }

        undo.executeUndo();
        RedoCommand.undoneCommandStack.push(undo);
        model.indicateFlexiTrackerChanged();
        return new CommandResult(MESSAGE_SUCCESS);
    }
   
}
```
###### /java/seedu/flexitrack/logic/commands/UnmarkCommand.java
``` java
    @Override
    public void executeUndo() {
        Task toDelete = unMarkedTask; 
        Task toAddBack = taskStore;
        
        try {
            model.deleteTask(toDelete);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }
        
        try {
            model.addTask(toAddBack);
        } catch (DuplicateTaskException e) {
            indicateAttemptToExecuteIncorrectCommand();
        }
    }
}
```
###### /java/seedu/flexitrack/logic/parser/Parser.java
``` java
    private static final Pattern TASK_FIND_GAP_WITH_NUMBER_ARGS_FORMAT = Pattern.compile("(?<info>[^/]+)"+"n/(?<numberOfGaps>[^/]+)");
    private static final Pattern TASK_FIND_GAP_ARGS_FORMAT = Pattern.compile("(?<info>[^/]+)");

    private static final Pattern TASK_EVENT_TYPE_DATA_ARGS_FORMAT = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile("(?<name>.+)" + "from/(?<startTime>[^/]+)" + "to/(?<endTime>[^/]+)"
                    + "(?<tagArguments>(?: t/[^/]+)*)"); // variable number of tags
    private static final Pattern TASK_DEADLINE_TYPE_DATA_ARGS_FORMAT = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile("(?<name>.+)" + "by/(?<dueDate>[^/]+)" + "(?<tagArguments>(?: t/[^/]+)*)"); // variable number of tags
    private static final Pattern TASK_FLOATING_TYPE_DATA_ARGS_FORMAT = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile("(?<name>.+)" + "(?<tagArguments>(?: t/[^/]+)*)"); // variable number of tags
```
###### /java/seedu/flexitrack/logic/parser/Parser.java
``` java
    /**
     * Prepare the user input arguments to be passed GapCommand class
     * 
     * @param args
     * @return a new Gap Command class
     */
    private Command prepareGap(String args) {
        args.toLowerCase();

        Matcher matcher = TASK_FIND_GAP_WITH_NUMBER_ARGS_FORMAT.matcher(args.trim());
        int numberOfSlot = GapCommand.DEFAULT_NUMBER_OF_SLOT;

        if (matcher.matches()) {
            args = matcher.group("info").trim();
            try {
                numberOfSlot = Integer.parseInt(matcher.group("numberOfGaps").trim());
            } catch (NumberFormatException nfe) {
                return new IncorrectCommand(
                        String.format(MESSAGE_INVALID_COMMAND_FORMAT, MESSAGE_NUMBER_NEED_TO_BE_IN_DIGIT));
            }
        } else {
            if (args.trim().equals("") || args.trim().contains("n/")) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, GapCommand.MESSAGE_USAGE));
            }
            matcher = TASK_FIND_GAP_ARGS_FORMAT.matcher(args.trim());
            matcher.matches();
            args = matcher.group("info").trim();
        }

        if (isGapArgumentValid(args)) {
            try {
                int keyword = extractKeywordFromArgs(args);
                int length = extractLength(args);
                return new GapCommand(keyword, length, numberOfSlot);

            } catch (NumberFormatException nfe) {
                return new IncorrectCommand(
                        String.format(MESSAGE_INVALID_COMMAND_FORMAT, MESSAGE_NUMBER_NEED_TO_BE_IN_DIGIT));
            }
        } else {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, GapCommand.MESSAGE_USAGE));
        }
    }

    /**
     * Extract the length of the duration from string in keywords to number
     * 
     * @param args
     * @return length of duration in integer
     * @throws NumberFormatException
     */
    private int extractLength(String args) throws NumberFormatException {
        String length = args.replace(GapCommand.WORD_DAY + "s", "").replace(GapCommand.WORD_HOUR + "s", "")
                .replace(GapCommand.WORD_MINUTE + "s", "").replace(GapCommand.WORD_DAY, "")
                .replace(GapCommand.WORD_HOUR, "").replace(GapCommand.WORD_MINUTE, "")
                .replace(GapCommand.INITIAL_DAY, "").replace(GapCommand.INITIAL_MINUTE, "")
                .replace(GapCommand.INITIAL_HOUR, "");
        if (length.trim().equals("")) {
            return 1;
        } else {
            return Integer.parseInt(length.trim());
        }
    }

    /**
     * Extract the keyword from the arguments and return it in integer reference
     * number
     * 
     * @param args
     * @return number representing each key word.
     */
    private int extractKeywordFromArgs(String args) {
        if (args.contains(GapCommand.WORD_DAY) || args.contains(GapCommand.WORD_DAY + "s")
                || args.contains(GapCommand.INITIAL_DAY)) {
            return GapCommand.REF_NO_DAY;
        }
        if (args.contains(GapCommand.WORD_HOUR) || args.contains(GapCommand.WORD_HOUR + "s")
                || args.contains(GapCommand.INITIAL_HOUR)) {
            return GapCommand.REF_NO_HOUR;
        } else {
            return GapCommand.REF_NO_MINUTE;
        }
    }

    /**
     * Find out if the argument is a valid argument for a GapCommand. The
     * argument could not have more than one timing key words ( minute, hour or
     * day )
     * 
     * @param args
     * @return true if the argument is a valid argument
     */
    private boolean isGapArgumentValid(String args) {
        int numberOfMatch = 0;

        if (args.contains(GapCommand.WORD_DAY) || args.contains(GapCommand.WORD_DAY + "s")
                || args.contains(GapCommand.INITIAL_DAY)) {
            numberOfMatch = numberOfMatch + 1;
        }
        if (args.contains(GapCommand.WORD_HOUR) || args.contains(GapCommand.WORD_HOUR + "s")
                || args.contains(GapCommand.INITIAL_HOUR)) {
            numberOfMatch = numberOfMatch + 1;
        }
        if (args.contains(GapCommand.WORD_MINUTE) || args.contains(GapCommand.WORD_MINUTE + "s")
                || args.contains(GapCommand.INITIAL_MINUTE)) {
            numberOfMatch = numberOfMatch + 1;
        }
        return numberOfMatch == 1;
    }

```
###### /java/seedu/flexitrack/logic/parser/Parser.java
``` java
    /**
     * Check if the arguments are valid for list Command
     * @param arguments
     * @return new List Command containing arguments
     */
    private Command prepareList(String arguments) {
        arguments=arguments.trim();
        try {
            if (isValideListFormat(arguments)) {
                return new ListCommand(arguments);
            }
        } catch (IllegalValueException e) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListCommand.MESSAGE_USAGE));
        }
        return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListCommand.MESSAGE_USAGE));
    }

```
###### /java/seedu/flexitrack/logic/parser/Parser.java
``` java
    /**
     * @param arguments
     * @return
     * @throws IllegalValueException 
     */
    private boolean isValideListFormat(String arguments) throws IllegalValueException {
        String dateInfo = (arguments.replace(ListCommand.LIST_FUTURE_COMMAND, "").replace(ListCommand.LIST_PAST_COMMAND, "").
                replace(ListCommand.LIST_UNMARK_COMMAND, "").replace(ListCommand.LIST_MARK_COMMAND, "").
                replace(ListCommand.LIST_LAST_MONTH_COMMAND, "").replace(ListCommand.LIST_LAST_WEEK_COMMAND, "").
                replace(ListCommand.LIST_NEXT_MONTH_COMMAND, "").replace(ListCommand.LIST_NEXT_WEEK_COMMAND, "").
                replace(ListCommand.LIST_BLOCK_COMMAND, "").trim());
        if ( !dateInfo.equals("") ){
            DateTimeInfoParser timeArgs = new DateTimeInfoParser(dateInfo);
        }
        return (arguments.contains(ListCommand.LIST_FUTURE_COMMAND) || arguments.contains(ListCommand.LIST_UNMARK_COMMAND)
                || arguments.contains(ListCommand.LIST_PAST_COMMAND) || arguments.contains(ListCommand.LIST_MARK_COMMAND)
                || arguments.contains(ListCommand.LIST_UNSPECIFIED_COMMAND) || arguments.contains(ListCommand.LIST_LAST_WEEK_COMMAND) 
                || arguments.contains(ListCommand.LIST_LAST_MONTH_COMMAND) || arguments.contains(ListCommand.LIST_NEXT_MONTH_COMMAND) 
                || arguments.contains(ListCommand.LIST_NEXT_WEEK_COMMAND) || arguments.contains(ListCommand.LIST_BLOCK_COMMAND));
    }

```
###### /java/seedu/flexitrack/logic/parser/Parser.java
``` java
    /**
     * Parses arguments in the context of the add task command.
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareAdd(String args) {
        final Matcher matcherEvent = TASK_EVENT_TYPE_DATA_ARGS_FORMAT.matcher(args.trim());
        final Matcher matcherDeadline = TASK_DEADLINE_TYPE_DATA_ARGS_FORMAT.matcher(args.trim());
        final Matcher matcherFloating = TASK_FLOATING_TYPE_DATA_ARGS_FORMAT.matcher(args.trim());
```
###### /java/seedu/flexitrack/logic/parser/Parser.java
``` java
        // Validate arg string format
        try {
```
###### /java/seedu/flexitrack/model/FlexiTrack.java
``` java
    /**
     * Find the next available time slots that has minimum gap as specified by
     * the users. If there are less gap then specified, return the starting time
     * where there are no more events
     * 
     * @param keyword       Represent the keyword in number. 0 represent minute and 4 represent years 
     * @param length        The length of the duration 
     * @param numberOfSlot  The number of slot to be found 
     * @return              The list of dates where gap are available
     */
    public List<DateTimeInfo> findNextAvailableSlots(int keyword, int length, int numberOfSlot) {
        DateTimeInfo dateNow = DateTimeInfo.getCurrentTime();
        List<DateTimeInfo> listOfPossibleTiming = new ArrayList<DateTimeInfo>();

        for (Task task : task.getInternalList()) {

            if (listOfPossibleTiming.size() > (numberOfSlot * 2 - 1)) {
                return listOfPossibleTiming;
            }

            if (canTheGapBeFound(task, dateNow, keyword, length)) {
                listOfPossibleTiming.add(dateNow);
                listOfPossibleTiming.add(task.getStartTime());
                dateNow = task.getEndTime();
            }

            if (dateNow.isInTheFuture(task.getEndTime())) {
                dateNow = task.getEndTime();
            }
        }
        listOfPossibleTiming.add(dateNow);
        return listOfPossibleTiming;
    }

    /**
     * Process the data to see if there is any gap available
     * 
     * @param task          The current task of interest 
     * @param dateNow       The current Date 
     * @param keyword       Represent the keyword in number. 0 represent minute and 4 represent years 
     * @param length        The length of the duration 
     * @return true when there is an available gap
     */
    private boolean canTheGapBeFound(Task task, DateTimeInfo dateNow, int keyword, int length) {
        if (task.getIsEvent() && dateNow.isInTheFuture(task.getStartTime())) {
            return isTheLengthOfTheGapSatisfied(task, dateNow, keyword, length);
        }
        return false;
    }

    /**
     * Process the task data to calculate if there is enough gap between the events
     * 
     * @param task      The current task of interest 
     * @param dateNow   The current date 
     * @param keyword   Represent the keyword in number. 0 represent minute and 4 represent years 
     * @param length    The length of the duration 
     * @return          True if the event starts after the current timing.
     */
    private boolean isTheLengthOfTheGapSatisfied(Task task, DateTimeInfo dateNow, int keyword, int length) {
        int[] differenceInTime = new int[5];
        differenceInTime = DateTimeInfo.durationBetweenTwoTiming(dateNow.toString(), task.getStartingTimeInString());
        if (differenceInTime[0] >= 0) {
            differenceInTime[keyword] = differenceInTime[keyword] - length;
            return doesTheGapAtLeastAsLongAsTimingSpecified(keyword, differenceInTime);
        }
        return false;
    }

    /**
     * Decide if the gap between two timing is long enough to satisfied the user
     * 
     * @param keyword           Represent the keyword in number. 0 represent minute and 4 represent years 
     * @param differenceInTime  The difference in time 
     * @return                  True if the gap is longer than what user specified.
     */
    private boolean doesTheGapAtLeastAsLongAsTimingSpecified(int keyword, int[] differenceInTime) {
        int countNumberOfZero = 0;
        for (int i = keyword; i < 5; i++) {
            if (differenceInTime[i] > 0) {
                return true;
            } else if (differenceInTime[i] == 0) {
                countNumberOfZero = countNumberOfZero + 1;
            }
        }
        return (countNumberOfZero == (5 - keyword)) ? true : false;
    }
    
}
```
###### /java/seedu/flexitrack/model/Model.java
``` java
    /** Updates the filter of the filtered task list to show future tasks */
    void updateFilteredListToFitUserInput( String args );
        
```
###### /java/seedu/flexitrack/model/Model.java
``` java
    /**
     * Refresh the TaskList Panel to reflect the changes made
     */
    void indicateFlexiTrackerChanged();

    /**
     * Find gap with length and number of slots specified by the user
     * @param keyword       Represent the keyword in number. 0 represent minute and 4 represent years 
     * @param length        The length of the duration 
     * @param numberOfSlot  The number of slot to be found 
     * @return The list of the Starting time and ending time for each gap found
     */
    List<DateTimeInfo> findSpecifiedGapTiming(int keyword, int length, int numberOfSlot);

}
```
###### /java/seedu/flexitrack/model/ModelManager.java
``` java
    @Override
    public void updateFilteredListToFitUserInput(String args){
        updateFilteredTaskList(new PredicateExpression(new DateQualifier(args)));
    }
    
```
###### /java/seedu/flexitrack/model/ModelManager.java
``` java
    /**
     * Helper class to process if a particular task should be shown on the list
     */
    private class DateQualifier implements Qualifier {
        private String keyWords;
        private String dateInfo;

        DateQualifier(String keyWord) {
            this.keyWords = keyWord;
            this.dateInfo = trimKeyWords(keyWord);
        }

        /**
         * Delete all the list command that is not date from the keywords
         * 
         * @param keyrordArgs   A string containing the keywords and other input
         * @return              The trimmed keyword in a string
         */
        private String trimKeyWords(String keyrordArgs) {
            return keyrordArgs.replace(ListCommand.LIST_FUTURE_COMMAND, "").replace(ListCommand.LIST_PAST_COMMAND, "")
                    .replace(ListCommand.LIST_UNMARK_COMMAND, "").replace(ListCommand.LIST_MARK_COMMAND, "")
                    .replace(ListCommand.LIST_LAST_WEEK_COMMAND, "").replace(ListCommand.LIST_LAST_MONTH_COMMAND, "")
                    .replace(ListCommand.LIST_NEXT_WEEK_COMMAND, "").replace(ListCommand.LIST_NEXT_MONTH_COMMAND, "")
                    .replace(ListCommand.LIST_BLOCK_COMMAND, "").trim();
        }

        @Override
        public boolean run(ReadOnlyTask task) {

            if (!isTaskGoingToBeShown(task)) {
                return false;
            }

            if (keyWords.contains(ListCommand.LIST_UNMARK_COMMAND)) {
                return !task.getIsDone();
            } else if (keyWords.contains(ListCommand.LIST_MARK_COMMAND)) {
                return task.getIsDone();
            } else if (keyWords.contains(ListCommand.LIST_BLOCK_COMMAND)) {
                return task.getIsBlock();
            }


            return isTaskGoingToBeShown(task);

        }

        /**
         * Check of the task will be shown to the user in the panel list
         * 
         * @param task  The current task of interest
         * @return      True if the task met all the requirement and will be shown
         */
        private boolean isTaskGoingToBeShown(ReadOnlyTask task) {
            if (keyWords.contains(ListCommand.LIST_FUTURE_COMMAND)) {
                return isTaskInTheFuture(task);
            } else if (keyWords.contains(ListCommand.LIST_PAST_COMMAND)) {
                return isTaskInThePast(task);
            } else if (keyWords.contains(ListCommand.LIST_LAST_COMMAND)
                    || keyWords.contains(ListCommand.LIST_NEXT_COMMAND)) {
                return isTaskWithinTheSpecifiedTiming(task);
            } else if (!dateInfo.equals("")) {
                return doesTaskCrossTheParticularStatedDate(task);
            } else {
                return true;
            }
        }

        /**
         * Process If the task happens on a particular date
         * 
         * @param task  The current task of interest
         * @return      True if task contain or cross the date
         */
        private boolean doesTaskCrossTheParticularStatedDate(ReadOnlyTask task) {
            DateTimeInfo dateTimeInfo=null;
            try {
                dateTimeInfo = new DateTimeInfo (dateInfo);
            } catch (IllegalValueException e) {
                //ADD LOG
            }
            return dateTimeInfo.isOnTheDate(task);
        }

        /**
         * Process if the task happens between now and the time stated
         * 
         * @param task
         *            The current task of interest
         * @return True if task is within the stated time
         */
        private boolean isTaskWithinTheSpecifiedTiming(ReadOnlyTask task) {
            return DateTimeInfo.withInTheDuration(keyWords, task, DateTimeInfo.getCurrentTime().toString());
        }

        /**
         * Process if a particular task has passed
         * 
         * @param task  The current task of interest
         * @return      True if it has passed
         */
        private boolean isTaskInThePast(ReadOnlyTask task) {
            return DateTimeInfo.getCurrentTime().isInThePast(task.getEndingTimeOrDueDate());
        }

        /**
         * Process if a particular task has not passed yet
         * 
         * @param task  The current task of interest
         * @return      True if it has not passed yet
         */
        private boolean isTaskInTheFuture(ReadOnlyTask task) {
            if (task.getIsNotFloatingTask()) {
                return DateTimeInfo.getCurrentTime().isInTheFuture(task.getEndingTimeOrDueDate());
            } else {
                return !task.getIsDone();
            }
        }
        
    }


}
```
###### /java/seedu/flexitrack/model/task/DateTimeInfo.java
``` java
package seedu.flexitrack.model.task;

import java.util.Date;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.joestelmach.natty.DateGroup;

import seedu.flexitrack.commons.exceptions.IllegalValueException;
import seedu.flexitrack.logic.commands.ListCommand;

/**
 * Represents a DateTimeInfo class in FlexiTrack
 */
public class DateTimeInfo implements Comparable<DateTimeInfo> {
    public static final String MESSAGE_DATETIMEINFO_CONSTRAINTS = "Invalid time inputed. Please check your spelling!";
    public static final String MESSAGE_FROM_IS_AFTER_TO = "Please check the timing inputed! The given starting time is after the ending time.";

    private static final Pattern TIME_TYPE_DATA_ARGS_FORMAT = Pattern.compile("(?<info>.+)");
    private static final int AVERAGE_DAYS_IN_A_MONTH = 30;
    private static final int DAYS_IN_A_WEEK = 7;
    private static final boolean FAIL_DUE_TO_EXCEPTION = false;

    private String setTime;
    private DateTimeInfoParser timeInfo;

    public DateTimeInfo(String givenTime) throws IllegalValueException {
        setDateGroupTime(givenTime);
    }

    /**
     * Set the setTime (DateGroup object) as the date inputed by the user
     * 
     * @param givenTime
     * @throws IllegalValueException
     */
    public void setDateGroupTime(String givenTime) throws IllegalValueException {
        assert givenTime != null;
        final Matcher matcher = TIME_TYPE_DATA_ARGS_FORMAT.matcher(givenTime.trim());
        matcher.matches();
        DateTimeInfoParser parsedTiming;
        try {
            parsedTiming = new DateTimeInfoParser(matcher.group("info"));
            timeInfo = parsedTiming;
            this.setTime = parsedTiming.getParsedTimingInfo();
            formatTimingIntoString(); 
        } catch (IllegalValueException e) {
            throw new IllegalValueException(MESSAGE_DATETIMEINFO_CONSTRAINTS);
        }
    }

    /**
     * A getter method for DateTimeInfoParser
     * 
     * @return DateTimeInfoParser of the timing of interest
     */
    public DateTimeInfoParser getTimeInfo() {
        return timeInfo;
    }

    private void formatTimingIntoString() { 
        this.setTime = getDateMonthYear() + " " + setTime.substring(12, 17);
    }
    
    /**
     * Change the format of the timing saved in setTime
     * 
     * @param inferred  True if the timing is inferred 
     */
    void formatStartOrDueDateTime() {
        if (timeInfo.isTimeInferred()) {
            setTime = setTime.substring(0, 12) + "08:00";
        } 
    }


    /**
     * If the time is inferred, replace "08:00" with "17:00"
     */
    void formatEndTime(DateTimeInfo startTime) {
        if (timeInfo.isDateInferred()) {
            setTime = startTime.setTime.substring(0, 12) + setTime.substring(12);
        } 
        if (timeInfo.isTimeInferred()) { 
            setTime = setTime.substring(0, 12) + "17:00";
        }
    }
    /**
     * Extract the month, date and year of a particular date
     * 
     * @return timing in MMM DD YYYY format
     */
    private String getDateMonthYear() {
        return setTime.substring(5, 12) + setTime.substring(25, 29);
    }

    /**
     * Validate the timing inputed
     * 
     * @param test  A date to be tested 
     * @return      True if it is a valid timing
     */
    public static boolean isValidDateTimeInfo(List<DateGroup> test) {
        return (!test.isEmpty()) ? true :  false;
    }

    /**
     * Change the months which is specified in string to integer
     * 
     * @param month     The month in written 3 letters string 
     * @return          Month in integer
     */
    public static int whatMonth(String month) {
        switch (month) {
        case "Jan":
            return 1;
        case "Feb":
            return 2;
        case "Mar":
            return 3;
        case "Apr":
            return 4;
        case "May":
            return 5;
        case "Jun":
            return 6;
        case "Jul":
            return 7;
        case "Aug":
            return 8;
        case "Sep":
            return 9;
        case "Oct":
            return 10;
        case "Nov":
            return 11;
        case "Dec":
            return 12;
        default:
            return 0;
        }
    }

    /**
     * To check if the minute inputed in 'from' is before the minute inputed in
     * 'to'
     * 
     * @param starting
     *            Time
     * @param ending
     *            Time
     * @return the duration of the event
     */
    public static String durationOfTheEvent(String startingTime, String endingTime) {
        return timeDifferenceInString(durationBetweenTwoTiming(startingTime, endingTime));
    }

    /**
     * prepare variables needed to calculate the duration between two timing
     * 
     * @param startingTime
     * @param endingTime
     * @return the duration of the event in an array. 0 represents minutes and 4
     *         represents years
     */
    public static int[] durationBetweenTwoTiming(String startingTime, String endingTime) {
        int years = differenceInYears(startingTime, endingTime);
        int months = differenceInMonths(startingTime, endingTime);
        int days = differenceInDays(startingTime, endingTime);
        int hours = differenceInHours(startingTime, endingTime);
        int minutes = differenceInMinutes(startingTime, endingTime);

        return combineDuratingOfEvent(years, months, days, hours, minutes);
    }

    /**
     * Put together the time difference that is represented in array into a String to be shown to the user 
     * 
     * @param timeDifference    The Time difference between two timing 
     * @return                  String of the message to be shown to the users 
     */
    private static String timeDifferenceInString(int[] timeDifference) {
        String duration = new String("");
        if (timeDifference[0] == -1) {
            return MESSAGE_FROM_IS_AFTER_TO;
        } else if (timeDifference[0] > 0) {
            duration = " " + timeDifference[0] + " minute" + ((timeDifference[0] == 1) ? "" + duration : "s");
        }
        if (timeDifference[1] > 0) {
            duration = " " + timeDifference[1] + " hour" + ((timeDifference[1] == 1) ? "" + duration : "s" + duration);
        }
        if (timeDifference[2] > 0) {
            duration = " " + timeDifference[2] + " day" + ((timeDifference[2] == 1) ? "" + duration : "s" + duration);
        }
        if (timeDifference[3] > 0) {
            duration = " " + timeDifference[3] + " month" + ((timeDifference[3] == 1) ? "" + duration : "s" + duration);
        }
        if (timeDifference[4] > 0) {
            duration = " " + timeDifference[4] + " year" + ((timeDifference[4] == 1) ? "" + duration : "s" + duration);
        }
        if (duration.equals("")) {
            return "Event starts and end at the same time.";
        } else {
            return "Duration of the event is: " + duration.trim() + ".";
        }
    }

    /**
     * Calculate the duration of the event
     * 
     * @param years
     * @param months
     * @param days
     * @param hours
     * @param minutes
     * @return the duration of the event in a string
     */
    private static int[] combineDuratingOfEvent(int years, int months, int days, int hours, int minutes) {
        int[] timeDifference = new int[5];

        if (minutes < 0) {
            minutes = Math.floorMod(minutes, 60);
            hours = hours - 1;
        }
        timeDifference[0] = minutes;
        if (hours < 0) {
            hours = Math.floorMod(hours, 24);
            days = days - 1;
        }
        timeDifference[1] = hours;
        if (days < 0) {
            days = Math.floorMod(days, 31);
            months = months - 1;
        }
        timeDifference[2] = days;
        if (months < 0) {
            months = Math.floorMod(months, 12);
            years = years - 1;
        }
        timeDifference[3] = months;
        if (years < 0) {
            timeDifference[0] = -1;
            return timeDifference;
        } else if (years > 0) {
            timeDifference[4] = years;
        }
        return timeDifference;

    }

    /**
     * Calculate the minute difference between the end and the start
     * 
     * @param startingTime  The starting time 
     * @param endingTime    The ending time 
     * @return              The minutes difference
     */
    private static int differenceInMinutes(String startingTime, String endingTime) {
        int startMinute = Integer.parseInt(startingTime.substring(15, 17));
        int endMinute = Integer.parseInt(endingTime.substring(15, 17));
        return endMinute - startMinute;
    }

    /**
     * Calculate the hour difference between the end and the start
     * 
     * @param startingTime  The starting time 
     * @param endingTime    The ending time 
     * @return              The hours difference
     */
    private static int differenceInHours(String startingTime, String endingTime) {
        int startHours = Integer.parseInt(startingTime.substring(12, 14));
        int endHours = Integer.parseInt(endingTime.substring(12, 14));
        return endHours - startHours;
    }

    /**
     * Calculate the day difference between the end and the start
     * 
     * @param startingTime  The starting time 
     * @param endingTime    The ending time 
     * @return              The days difference
     */
    private static int differenceInDays(String startingTime, String endingTime) {
        int startDate = Integer.parseInt(startingTime.substring(4, 6));
        int endDate = Integer.parseInt(endingTime.substring(4, 6));
        return endDate - startDate;
    }

    /**
     * Calculate the year difference between the end and the start
     * 
     * @param startingTime  The starting time 
     * @param endingTime    The ending time 
     * @return              The years difference
     */
    private static int differenceInYears(String startingTime, String endingTime) {
        int startYear = Integer.parseInt(startingTime.substring(7, 11));
        int endYear = Integer.parseInt(endingTime.substring(7, 11));
        return endYear - startYear;
    }

    /**
     * Calculate the month difference between the end and the start
     * 
     * @param startingTime  The starting time 
     * @param endingTime    The ending time 
     * @return              The months difference
     */
    private static int differenceInMonths(String startingTime, String endingTime) {
        String startMonth = startingTime.substring(0, 3);
        String endMonth = endingTime.substring(0, 3);
        int monthDifference = whatMonth(endMonth) - whatMonth(startMonth);
        return monthDifference;
    }

    @Override
    public String toString() {
        return setTime;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof DateTimeInfo // instanceof handles nulls
                        && this.setTime.equals(((DateTimeInfo) other).setTime)); // state check
    }

    @Override
    public int hashCode() {
        return setTime.hashCode();
    }

    /**
     * @return true if the date not specified;
     */
    public boolean isDateNull() {
        return this.setTime.equals("Feb 29 2000 00:00");
    }

    /**
     * Process the task if the task is in the future
     * 
     * @param Date
     *            Timing to be compared to the current timing
     * @return True if the timing timeNow is after the timing Date
     */
    public boolean isInTheFuture(DateTimeInfo Date) {
        int[] duration = durationBetweenTwoTiming(this.toString(), Date.toString());
        return duration[0] != -1;
    }

    /**
     * Process the task if the task is in the past
     * 
     * @param Date      Timing to be compared to the current timing 
     * @return          True if the timing timeNow is before the timing Date
     */
    public boolean isInThePast(DateTimeInfo Date) {
        return !this.isInTheFuture(Date);
    }

    /**
     * Prepare the keyword and process if the task is within the specified date.
     * For a task the due date is the dateInfo date. For an event, the specified
     * DateInfo date is within the event duration (inclusive the starting and
     * the ending date)
     * 
     * @param dateInfo  The date of interest
     * @param task      The task of interest
     * @return          True if the task is within the specified date
     */
    public boolean isOnTheDate(ReadOnlyTask task) {
        return task.getDueDate().toString().contains(toString().substring(0, 12))
                || task.getEndTime().toString().contains(toString().substring(0, 12))
                || task.getStartTime().toString().contains(toString().substring(0, 12))
                || isTaskAnEventPassingThisDate(task, toString().substring(0, 12));
    }

    /**
     * Process the data if it the task is a event and it is passing through the
     * date specified.
     * 
     * @param task      The event of interest
     * @param dateInfo  The date of interest
     * @return          True if a task is an event and the day interest is within the
     *                  starting date and the ending date
     */
    static boolean isTaskAnEventPassingThisDate(ReadOnlyTask task, String dateInfo) {
        if (!task.getIsEvent()) {
            return false;
        }
        DateTimeInfo dateSpecified;
        try {
            dateSpecified = new DateTimeInfo(dateInfo);
            return task.getStartTime().isInTheFuture(dateSpecified) && dateSpecified.isInTheFuture(task.getEndTime());
        } catch (IllegalValueException e) {
            new IllegalValueException(MESSAGE_DATETIMEINFO_CONSTRAINTS);
        }
        return FAIL_DUE_TO_EXCEPTION;
    }

    /**
     * Process if the a task specified is with in the duration stated.
     * 
     * @param keyWords  The keywords of the list command enter by the user 
     * @param task      the task of interest 
     * @return          True if the date is within the duration
     */
    public static boolean withInTheDuration(String keyWords, ReadOnlyTask task, String dateNow) {
        boolean isWithInTime = false;
        if (keyWords.contains(ListCommand.LIST_LAST_WEEK_COMMAND)) {
            return isNotFloatingTaskAndWithinTheTime(task, dateNow, -DAYS_IN_A_WEEK);
        } else if (keyWords.contains(ListCommand.LIST_LAST_MONTH_COMMAND)) {
            return isNotFloatingTaskAndWithinTheTime(task, dateNow, -AVERAGE_DAYS_IN_A_MONTH);
        } else if (keyWords.contains(ListCommand.LIST_NEXT_MONTH_COMMAND)) {
            return isNotFloatingTaskAndWithinTheTime(task, dateNow, AVERAGE_DAYS_IN_A_MONTH);
        } else if (keyWords.contains(ListCommand.LIST_NEXT_WEEK_COMMAND)) {
            return isNotFloatingTaskAndWithinTheTime(task, dateNow, DAYS_IN_A_WEEK);
        }
        return isWithInTime;
    }

    /**
     * Process if the task given is either a deadline task or an event within
     * the specified timing
     * 
     * @param task          The task of interest 
     * @param dateNow       The current date 
     * @param expectedDays  The longest timing accepted 
     * @return              True if the task is not a floating task and it is within the
     *                      specified timing
     */
    private static boolean isNotFloatingTaskAndWithinTheTime(ReadOnlyTask task, String dateNow, int expectedDays) {
        return (task.getIsNotFloatingTask())
                ? isTimeDifferenceLessThanSpecified(dateNow, task.getStartingTimeOrDueDate().toString(), expectedDays)
                : false;
    }

    /**
     * Provide an easy access to the current timing in String
     * 
     * @return String of the current time MMM DD YYYY HH:MM format.
     */
    public static DateTimeInfo getCurrentTime() {
        DateTimeInfo dateNow = null;
        try {
            dateNow = new DateTimeInfo("now");
        } catch (IllegalValueException e) {
            assert false;
        }
        return dateNow;
    }

    /**
     * Process if the two given time is less than the time duration.
     * 
     * @param startTime         The starting time of the duration  
     * @param endTime           The ending time of the duration 
     * @param limitTimeDuration The maximum duration allowed 
     * @return                  True if the time Difference is less than specified
     */
    private static boolean isTimeDifferenceLessThanSpecified(String startTime, String endTime, int limitTimeDuration) {
        if (limitTimeDuration < 0) {
            limitTimeDuration = limitTimeDuration * (-1);
            return isTimeDifferenceLessThanSpecified(endTime, startTime, limitTimeDuration);
        }

        int years = differenceInYears(startTime, endTime);
        int months = differenceInMonths(startTime, endTime);
        int days = differenceInDays(startTime, endTime);
        int hours = differenceInHours(startTime, endTime);

        return isTimeLessThanSpecified(limitTimeDuration, years, months, days, hours);
    }

    /**
     * Helper method to check the duration of a specified timing is with in the
     * time duration
     * 
     * @param limitTimeDuration The maximum time duration 
     * @param years             The difference in years between the two timing
     * @param months            The difference in months between the two timing
     * @param days              The difference in days between the two timing
     * @param hours             The difference in hours between the two timing
     * @return                  True if the time is within the specified timing
     */
    private static boolean isTimeLessThanSpecified(int limitTimeDuration, int years, int months, int days, int hours) {
        if (hours < 0) {
            hours = Math.floorMod(hours, 24);
            days = days - 1;
        }
        if (days < 0) {
            days = Math.floorMod(days, 30);
            months = months - 1;
        }
        if (months < 0 || months > 1) {
            return false;
        }
        if (years < 0 || years > 0) {
            return false;
        }
        if ((days <= limitTimeDuration && months == 0)
                || (limitTimeDuration == AVERAGE_DAYS_IN_A_MONTH && months == 1)) {
            return true;
        } else {
            return false;
        }
    }

    // @@ author
    @Override
    public int compareTo(DateTimeInfo dateTimeInfo2) {
        Date dateObject1 = convertToDateObject(this.setTime);
        Date dateObject2 = convertToDateObject(dateTimeInfo2.setTime);
        return dateObject1.compareTo(dateObject2);
    }

    private Date convertToDateObject(String dateString) {
        try {
            DateTimeInfoParser parsedTiming = new DateTimeInfoParser(dateString);
            return parsedTiming.getParsedDateTime();
        } catch (IllegalValueException ive) {
            return null;
        }

    }

}
```
###### /java/seedu/flexitrack/model/task/DateTimeInfoParser.java
``` java
/**
 * Represents the Parser and Time related DateTimeInfo.
 */
public class DateTimeInfoParser {

    public static final String MESSAGE_DATETIMEINFO_CONSTRAINTS = "Invalid time inputed. Please check your spelling!";

    private DateGroup timingInfo;

    public DateTimeInfoParser(String givenTime) throws IllegalValueException {
        try {
            Parser parser = new Parser();
            List<DateGroup> dateParser = parser.parse(givenTime);
            setTimingInfo(dateParser);
        } catch (IndexOutOfBoundsException e) {
            throw new IllegalValueException(MESSAGE_DATETIMEINFO_CONSTRAINTS);
        }
    }

    /**
     * Set the timingInfo variable with the time specified
     * 
     * @param dateParser
     */
    private void setTimingInfo(List<DateGroup> dateParser) {
        this.timingInfo = dateParser.get(0);
    }

    public String getParsedTimingInfo() {
        return timingInfo.getDates().toString();
    }
    
    public boolean isTimeInferred() {
        return timingInfo.isTimeInferred();
    }
    
    public boolean isDateInferred() {
        return timingInfo.isDateInferred();
    }

```
###### /java/seedu/flexitrack/model/task/Name.java
``` java
    @Override
    public String toString(){ 
        return isDonePrefix + isBlockPrefix + name; 
    }

    public String getNameOnly(){ 
        return name; 
    }

    public String setAsMark(){ 
        return isDonePrefix = DONE_PREFIX; 
    }

    public String setAsUnmark(){ 
        name = name.replace(DONE_PREFIX, "");
        return isDonePrefix = ""; 
    }
}
```
###### /java/seedu/flexitrack/model/task/ReadOnlyTask.java
``` java
    default public boolean getIsNotFloatingTask(){
        return (this.getIsEvent() || this.getIsTask());
    }
    
    default public DateTimeInfo getStartingTimeOrDueDate(){
        if (this.getIsTask()){
            return this.getDueDate();
        } else {
            return  this.getStartTime();
        }
    }
    
    default public DateTimeInfo getEndingTimeOrDueDate(){
        if (this.getIsTask()){
            return this.getDueDate();
        } else {
            return  this.getEndTime();
        }
    }
    
}
```
