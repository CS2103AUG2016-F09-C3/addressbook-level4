# A0127686R
###### /java/seedu/flexitrack/logic/commands/AddCommand.java
``` java
    @Override
    public void executeUndo() {
        Task toDelete = new Task (storeDataChanged.peek());

        try {
            model.deleteTask(toDelete);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }
        
        storeDataChanged.pop();
    }

}
```
###### /java/seedu/flexitrack/logic/commands/Command.java
``` java
    public void recordCommand(String command){
        UndoCommand.commandRecord.add(command); 
    }
}
```
###### /java/seedu/flexitrack/logic/commands/EditCommand.java
``` java
    @Override
    public void executeUndo() {
        Task toDelete = new Task (storeNewDataChanged.peek()); 
        Task toAddBack = new Task (storeOldDataChanged.peek());

        try {
            model.deleteTask(toDelete);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }
        
        try {
            model.addTask(toAddBack);
        } catch (DuplicateTaskException e) {
            indicateAttemptToExecuteIncorrectCommand();
        }
        
        model.indicateFlexiTrackerChanged();

        storeNewDataChanged.pop();
        storeOldDataChanged.pop();
    }
}
```
###### /java/seedu/flexitrack/logic/commands/ListCommand.java
``` java
package seedu.flexitrack.logic.commands;

/**
 * Lists all task in the FlexiTrack to the user.
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = "list";
    public static final String COMMAND_SHORTCUT = "l";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ", Shortcut [" + COMMAND_SHORTCUT + "]" + 
            ": List all the to do lists in FlexiTrack.\n" 
            + COMMAND_WORD + " future : List all the to do lists that is due or start in the future.\n"
            + COMMAND_WORD + " past : List all the to do lists in the past.\n"
            + COMMAND_WORD + " mark: List all the to do lists that has been marked.\n"
            + COMMAND_WORD + " unmark: List all the to do lists in that has not been marked.\n"
            + "Example: " + COMMAND_WORD + " past \n";
    public static final String MESSAGE_SUCCESS = "Listed all tasks";
    public static final String LIST_FUTURE_COMMAND = "future";
    public static final String LIST_PAST_COMMAND = "past";
    public static final String LIST_MARK_COMMAND = "mark";
    public static final String LIST_UNMARK_COMMAND = "unmark";
    public static final String LIST_BLOCK_COMMAND = "block";
    public static final String LIST_LAST_COMMAND = "last";
    public static final String LIST_NEXT_COMMAND = "next";
    public static final String LIST_LAST_WEEK_COMMAND = "last week";
    public static final String LIST_LAST_MONTH_COMMAND = "last month";
    public static final String LIST_NEXT_WEEK_COMMAND = "next week";
    public static final String LIST_NEXT_MONTH_COMMAND = "next month";
    public static final String LIST_UNSPECIFIED_COMMAND = "";
            
    public final String arguments;
    
    public ListCommand(String args) {
        this.arguments = args; 
    }

    @Override
    public CommandResult execute() {
        if (arguments.equals(LIST_UNSPECIFIED_COMMAND)){
            model.updateFilteredListToShowAll();
        }
        else {
            model.updateFilteredListToFitUserInput( arguments );
        }      
        return new CommandResult(MESSAGE_SUCCESS);
    }

}
```
###### /java/seedu/flexitrack/logic/commands/MarkCommand.java
``` java
    @Override
    public void executeUndo() {
        Task toDelete = new Task (storeDataChanged.peek()); 
        Task toAddBack = null;
        try {
            toAddBack = new Task (new Name (storeDataChanged.peek().getName().toString()), 
                    new DateTimeInfo (storeDataChanged.peek().getDueDate().toString()), 
                    new DateTimeInfo ( storeDataChanged.peek().getStartTime().toString()), 
                    new DateTimeInfo (storeDataChanged.peek().getEndTime().toString()), 
                    new UniqueTagList (storeDataChanged.peek().getTags()));
        } catch (IllegalValueException e1) {
            assert false : "There Should not be any Illegal values s";
        }
        toAddBack.getName().setAsUnmark();

        try {
            model.deleteTask(toDelete);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }
        
        try {
            model.addTask(toAddBack);
        } catch (DuplicateTaskException e) {
            indicateAttemptToExecuteIncorrectCommand();
        }
        
        storeDataChanged.pop();
    }
}
```
###### /java/seedu/flexitrack/logic/commands/UndoCommand.java
``` java
package seedu.flexitrack.logic.commands;

import java.util.Stack;

/**
 * Clears the FlexiTrack.
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";
    public static final String COMMAND_SHORTCUT = "ud"; // TODO: impiment ctrl + Z 
    public static final String MESSAGE_USAGE = COMMAND_WORD  + ", Shortcut [" + COMMAND_SHORTCUT + "]" + ": Clear the to do lists in FlexiTrack.\n" + "Example: "
            + COMMAND_WORD;
    public static final String MESSAGE_SUCCESS = "Your last command has been undo!";
    public static final String MESSAGE_NOT_SUCCESS = "You have no command to undo!";
    
    static Stack<String> commandRecord = new Stack<String>(); 

    public UndoCommand() {
    }

    @Override
    public CommandResult execute() {
        Command undo = null; 
        if (commandRecord.size() == 0 ){ 
            return new CommandResult(String.format(MESSAGE_NOT_SUCCESS));
        }
        switch (commandRecord.peek()){
        case "add":   
            undo = new AddCommand();
            break; 
        case "delete":   
            undo = new DeleteCommand();
            break; 
        case "mark":   
            undo = new MarkCommand(); 
            break;
        case "unmark":  
            undo = new UnmarkCommand(); 
            break;
        case "clear": 
            undo = new ClearCommand(); 
            break; 
        case "edit":   
            undo = new EditCommand(); 
            break;            
        case "block":   
            undo = new BlockCommand(); 
            break;
        }
        undo.setData(model);
        assert undo != null; 
        undo.executeUndo();
        commandRecord.pop();
        model.indicateFlexiTrackerChanged();
        return new CommandResult(MESSAGE_SUCCESS);
    }
    
   
}
```
###### /java/seedu/flexitrack/logic/commands/UnmarkCommand.java
``` java
    @Override
    public void executeUndo() {
        Task toDelete = new Task (storeDataChanged.peek()); 
        Task toAddBack = null;
        try {
            toAddBack = new Task (new Name (storeDataChanged.peek().getName().toString()), 
                    new DateTimeInfo (storeDataChanged.peek().getDueDate().toString()), 
                    new DateTimeInfo ( storeDataChanged.peek().getStartTime().toString()), 
                    new DateTimeInfo (storeDataChanged.peek().getEndTime().toString()), 
                    new UniqueTagList (storeDataChanged.peek().getTags()));
        } catch (IllegalValueException e1) {
            assert false : "There Should not be any Illegal values s";
        }
        toAddBack.getName().setAsMark();

        try {
            model.deleteTask(toDelete);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }
        
        try {
            model.addTask(toAddBack);
        } catch (DuplicateTaskException e) {
            indicateAttemptToExecuteIncorrectCommand();
        }
        
        storeDataChanged.pop();
        
    }
}
```
###### /java/seedu/flexitrack/logic/parser/Parser.java
``` java
    private static final Pattern TASK_EVENT_TYPE_DATA_ARGS_FORMAT = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile("(?<name>.+)" + "from/(?<startTime>[^/]+)" + "to/(?<endTime>[^/]+)"
                    + "(?<tagArguments>(?: t/[^/]+)*)"); // variable number of tags
    private static final Pattern TASK_DEADLINE_TYPE_DATA_ARGS_FORMAT = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile("(?<name>.+)" + "by/(?<dueDate>[^/]+)" + "(?<tagArguments>(?: t/[^/]+)*)"); // variable number of tags
    private static final Pattern TASK_FLOATING_TYPE_DATA_ARGS_FORMAT = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile("(?<name>.+)" + "(?<tagArguments>(?: t/[^/]+)*)"); // variable number of tags
```
###### /java/seedu/flexitrack/logic/parser/Parser.java
``` java
    /**
     * Check if the arguments are valid for list Command
     * @param arguments
     * @return new List Command containing arguments
     */
    private Command prepareList(String arguments) {
        arguments=arguments.trim();
        try {
            if (isValideListFormat(arguments)) {
                return new ListCommand(arguments);
            }
        } catch (IllegalValueException e) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListCommand.MESSAGE_USAGE));
        }
        return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListCommand.MESSAGE_USAGE));
    }

```
###### /java/seedu/flexitrack/logic/parser/Parser.java
``` java
    /**
     * @param arguments
     * @return
     * @throws IllegalValueException 
     */
    private boolean isValideListFormat(String arguments) throws IllegalValueException {
        String dateInfo = (arguments.replace(ListCommand.LIST_FUTURE_COMMAND, "").replace(ListCommand.LIST_PAST_COMMAND, "").
                replace(ListCommand.LIST_UNMARK_COMMAND, "").replace(ListCommand.LIST_MARK_COMMAND, "").
                replace(ListCommand.LIST_LAST_MONTH_COMMAND, "").replace(ListCommand.LIST_LAST_WEEK_COMMAND, "").
                replace(ListCommand.LIST_NEXT_MONTH_COMMAND, "").replace(ListCommand.LIST_NEXT_WEEK_COMMAND, "").
                replace(ListCommand.LIST_BLOCK_COMMAND, "").trim());
        if ( !dateInfo.equals("") ){
            DateTimeInfoParser timeArgs = new DateTimeInfoParser(dateInfo);
        }
        return (arguments.contains(ListCommand.LIST_FUTURE_COMMAND) || arguments.contains(ListCommand.LIST_UNMARK_COMMAND)
                || arguments.contains(ListCommand.LIST_PAST_COMMAND) || arguments.contains(ListCommand.LIST_MARK_COMMAND)
                || arguments.contains(ListCommand.LIST_UNSPECIFIED_COMMAND) || arguments.contains(ListCommand.LIST_LAST_WEEK_COMMAND) 
                || arguments.contains(ListCommand.LIST_LAST_MONTH_COMMAND) || arguments.contains(ListCommand.LIST_NEXT_MONTH_COMMAND) 
                || arguments.contains(ListCommand.LIST_NEXT_WEEK_COMMAND) || arguments.contains(ListCommand.LIST_BLOCK_COMMAND));
    }

```
###### /java/seedu/flexitrack/logic/parser/Parser.java
``` java
    /**
     * Parses arguments in the context of the add task command.
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareAdd(String args) {
        final Matcher matcherEvent = TASK_EVENT_TYPE_DATA_ARGS_FORMAT.matcher(args.trim());
        final Matcher matcherDeadline = TASK_DEADLINE_TYPE_DATA_ARGS_FORMAT.matcher(args.trim());
        final Matcher matcherFloating = TASK_FLOATING_TYPE_DATA_ARGS_FORMAT.matcher(args.trim());
```
###### /java/seedu/flexitrack/logic/parser/Parser.java
``` java
        // Validate arg string format
        try {
            if (matcherRecurring.matches()) {
                return addRecurringEvent(matcherRecurring);
            }else if (matcherEvent.matches()) {
                return addEventTask(matcherEvent);
            } else if (matcherDeadline.matches()) {
                return addDeadlineTask(matcherDeadline);
            } else if (matcherFloating.matches()) {
                return addFloatingTask(matcherFloating);
            } else {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
            }
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    private AddCommand addFloatingTask(Matcher matcher) throws IllegalValueException {
        return new AddCommand(matcher.group("name"), EMPTY_TIME_INFO, EMPTY_TIME_INFO, EMPTY_TIME_INFO,
                getTagsFromArgs(matcher.group("tagArguments")));
    }

    private AddCommand addDeadlineTask(Matcher matcher) throws IllegalValueException {
        return new AddCommand(matcher.group("name"), matcher.group("dueDate"), EMPTY_TIME_INFO, EMPTY_TIME_INFO,
                getTagsFromArgs(matcher.group("tagArguments")));
    }
    
    
    private AddCommand addEventTask(Matcher matcher) throws IllegalValueException {
        return new AddCommand(matcher.group("name"), EMPTY_TIME_INFO, matcher.group("startTime"),
                matcher.group("endTime"), getTagsFromArgs(matcher.group("tagArguments")));
    }
    
```
###### /java/seedu/flexitrack/model/Model.java
``` java
    /** Updates the filter of the filtered task list to show future tasks */
    void updateFilteredListToFitUserInput( String args );
        
```
###### /java/seedu/flexitrack/model/ModelManager.java
``` java
    @Override
    public void updateFilteredListToFitUserInput(String args){
        updateFilteredTaskList(new PredicateExpression(new DateQualifier(args)));
    }
    
```
###### /java/seedu/flexitrack/model/ModelManager.java
``` java
    private class DateQualifier implements Qualifier {
        private String keyWords;
        private String dateInfo; 

        DateQualifier(String keyWord) {
            this.keyWords = keyWord;
            this.dateInfo = trimKeyWords(keyWord);
        }

        /**
         * Delete all the list command that is not date from the keywords
         * @param keyWord
         * @return
         */
        private String trimKeyWords(String keyWord) {
            return keyWord.replace(ListCommand.LIST_FUTURE_COMMAND, "").replace(ListCommand.LIST_PAST_COMMAND, "")
                    .replace(ListCommand.LIST_UNMARK_COMMAND, "").replace(ListCommand.LIST_MARK_COMMAND, "")
                    .replace(ListCommand.LIST_LAST_WEEK_COMMAND, "").replace(ListCommand.LIST_LAST_MONTH_COMMAND, "")
                    .replace(ListCommand.LIST_NEXT_WEEK_COMMAND, "").replace(ListCommand.LIST_NEXT_MONTH_COMMAND, "")
                    .replace(ListCommand.LIST_BLOCK_COMMAND, "").trim();
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            
            if (!isTaskGoingToBeShown(task)){ 
                return false; 
            }
            
            if (keyWords.contains(ListCommand.LIST_UNMARK_COMMAND)){
                return !task.getIsDone();
            } else if (keyWords.contains(ListCommand.LIST_MARK_COMMAND)){
                return task.getIsDone();
            }
            
            return isTaskGoingToBeShown(task);
            
        }

        /**
         * @param task
         * @param willBeShown
         * @return
         */
        private boolean isTaskGoingToBeShown(ReadOnlyTask task) {
            if (keyWords.contains(ListCommand.LIST_FUTURE_COMMAND)) {
                return isTaskInTheFuture(task);
            } else if (keyWords.contains(ListCommand.LIST_PAST_COMMAND)){
                return isTaskInThePast(task);
            } else if (keyWords.contains(ListCommand.LIST_LAST_COMMAND) || keyWords.contains(ListCommand.LIST_NEXT_COMMAND)){
                return isTaskWithinTheSpecifiedTiming(task);
            } else if (!dateInfo.equals("")){
                return doesTaskCrossTheParticularStatedDate(task);
            } else { 
                return true; 
            }
        }

        /**
         * Process If the task happens on a particular date 
         * @param task
         * @return true if task contain or cross the date
         */
        private boolean doesTaskCrossTheParticularStatedDate(ReadOnlyTask task) {
            return DateTimeInfo.isOnTheDate(dateInfo, task);
        }

        /**
         * Process if the task happens between now and the time stated 
         * @param task
         * @return true if task is within the stated time
         */
        private boolean isTaskWithinTheSpecifiedTiming(ReadOnlyTask task) {
            return DateTimeInfo.withInTheDuration(keyWords, task, DateTimeInfo.getCurrentTimeInString().toString());
        }

        /**
         * Process if a particular task has passed
         * @param task
         * @return true if it has passed
         */
        private boolean isTaskInThePast(ReadOnlyTask task) {
            return DateTimeInfo.isInThePast(DateTimeInfo.getCurrentTimeInString(), task.getEndingTimeOrDueDate());
        }

        /**
         * Process if a particular task has not passed yet
         * @param task
         * @return true if it has not passed yet
         */
        private boolean isTaskInTheFuture(ReadOnlyTask task) {
            if (task.getIsNotFloatingTask()){ 
                return DateTimeInfo.isInTheFuture(DateTimeInfo.getCurrentTimeInString(), task.getEndingTimeOrDueDate());
            }else { 
                return !task.getIsDone();
            }
        }
        
    }

}
```
###### /java/seedu/flexitrack/model/task/DateTimeInfo.java
``` java
package seedu.flexitrack.model.task;

import java.util.Date;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.joestelmach.natty.DateGroup;

import seedu.flexitrack.commons.exceptions.IllegalValueException;
import seedu.flexitrack.logic.commands.ListCommand;

/**
 * Represents a DateTimeInfo class in FlexiTrack
 */
public class DateTimeInfo implements Comparable<DateTimeInfo>{
    public static final String MESSAGE_DATETIMEINFO_CONSTRAINTS = "Invalid time inputed. Please check your spelling!";
    public static final String MESSAGE_FROM_IS_AFTER_TO = "Please check the timing inputed! The given starting time is after the ending time.";

    private static final Pattern TIME_TYPE_DATA_ARGS_FORMAT = Pattern.compile("(?<info>.+)");
    private static final int AVERAGE_DAYS_IN_A_MONTH = 30; 
    private static final int DAYS_IN_A_WEEK = 7;
    private static final boolean FAIL_DUE_TO_EXCEPTION = false; 
    
    private String setTime;
    private DateTimeInfoParser timeInfo;
    
    public DateTimeInfo(String givenTime) throws IllegalValueException {
        setDateGroupTime(givenTime);
    }

    /**
     * Set the setTime (DateGroup object) as the date inputed by the user
     * 
     * @param givenTime
     * @throws IllegalValueException 
     */
    public void setDateGroupTime(String givenTime) throws IllegalValueException {
        assert givenTime != null;
        final Matcher matcher = TIME_TYPE_DATA_ARGS_FORMAT.matcher(givenTime.trim());
        matcher.matches();
        DateTimeInfoParser parsedTiming;
        try {
            parsedTiming = new DateTimeInfoParser(matcher.group("info"));
            timeInfo = parsedTiming;
            this.setTime = parsedTiming.getParsedTimingInfo();
            formatTiming(parsedTiming.isInferred());
        } catch (IllegalValueException e) {
            throw new IllegalValueException (MESSAGE_DATETIMEINFO_CONSTRAINTS);
        }
    }
    
    public DateTimeInfoParser getTimeInfo() {
        return timeInfo;
    }

    /**
     * Change the format of the timing saved in setTime 
     * @param inferred
     */
    private void formatTiming(boolean inferred) {
        if (inferred) {
            setTime = getDateMonthYear() + " 07:59";
        } else {
            setTime = getDateMonthYear() + " " + setTime.substring(12, 17);
        }
    }

    /**
     * Extract the month, date and year of a particular date 
     * @return timing in MMM DD YYYY format 
     */
    private String getDateMonthYear() {
        return setTime.substring(5, 12) + setTime.substring(25, 29);
    }

    /**
     * Validate the timing inputed
     * 
     * @param test
     * @return true if it is a valid timing
     */
    public static boolean isValidDateTimeInfo(List<DateGroup> test) {
        if (!test.isEmpty()) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Change the months which is specified in string to integer
     * 
     * @param month
     * @return month in integer
     */
    public static int whatMonth(String month) {
        switch (month) {
        case "Jan":
            return 1;
        case "Feb":
            return 2;
        case "Mar":
            return 3;
        case "Apr":
            return 4;
        case "May":
            return 5;
        case "Jun":
            return 6;
        case "Jul":
            return 7;
        case "Aug":
            return 8;
        case "Sep":
            return 9;
        case "Oct":
            return 10;
        case "Nov":
            return 11;
        case "Dec":
            return 12;
        default:
            return 0;
        }
    }

    /**
     * To check if the minute inputed in 'from' is before the minute inputed in
     * 'to'
     * 
     * @param starting Time
     * @param ending Time
     * @return the duration of the event
     */
    public static String durationOfTheEvent(String startingTime, String endingTime) {
        return durationBetweenTwoTiming(startingTime,endingTime);
    }

    /** 
     * prepare variables needed to calculate the duration between two timing 
     * @param startingTime
     * @param endingTime
     * @return the duration of the event in a string
     */
    private static String durationBetweenTwoTiming(String startingTime, String endingTime) {
        int years = yearsOfTheEvent(startingTime, endingTime);
        int months = monthsOfTheEvent(startingTime, endingTime);
        int days = daysOfTheEvent(startingTime, endingTime);
        int hours = hoursOfTheEvent(startingTime, endingTime);
        int minutes = minutesOfTheEvent(startingTime, endingTime);

        return combineDuratingOfEvent(years, months, days, hours, minutes);        
    }

    /**
     * Calculate the duration of the event
     * @param years
     * @param months
     * @param days
     * @param hours
     * @param minutes
     * @return the duration of the event in a string 
     */
    private static String combineDuratingOfEvent(int years, int months, int days, int hours, int minutes) {
        String duration1 = new String("");

        if (minutes > 0 || minutes < 0) {
            if (minutes < 0) {
                minutes = Math.floorMod(minutes, 60);
                hours=hours-1;
            }
            duration1 = " " + minutes + " minute" + ((minutes == 1) ? "" : "s");
        }
        if (hours < 0) {
            hours = Math.floorMod(hours, 24);
            days=days-1;
        } 
        if(hours > 0){
            duration1 = " " + hours + " hour" + ((hours == 1) ? "" : "s" + duration1);
        }
        if (days < 0) {
            days = Math.floorMod(days, 31);
            months=months-1;
        }
        if(days>0){
            duration1 = " " + days + " day" + ((days == 1) ? "" : "s" + duration1);
        }
        if (months < 0) {
            months = Math.floorMod(months, 12);
            years=years-1;
        }
        if(months>0){
            duration1 = " " + months + " month" + ((months == 1) ? "" : "s" + duration1);
        }
        if (years < 0) {
            return MESSAGE_FROM_IS_AFTER_TO;
        } else if (years > 0) {
            duration1 = " " + years + " year" + ((years == 1) ? "" : "s" + duration1);
        }

        if (minutes == 0 && hours == 0 && days == 0 && months == 0) {
            duration1 = "Event starts and end at the same time.";
        } else {
            duration1 = "Duration of the event is: " + duration1.trim() + ".";
        }
        return duration1;

    }

    /**
     * Calculate the minute difference between the end and the start
     * 
     * @param startingTime
     * @param endingTime
     * @return the minute difference
     */
    private static int minutesOfTheEvent(String startingTime, String endingTime) {
        int startMinute = Integer.parseInt(startingTime.substring(15, 17));
        int endMinute = Integer.parseInt(endingTime.substring(15, 17));
        return endMinute - startMinute;
    }

    /**
     * Calculate the hour difference between the end and the start
     * 
     * @param startingTime
     * @param endingTime
     * @return the hour difference
     */
    private static int hoursOfTheEvent(String startingTime, String endingTime) {
        int startHours = Integer.parseInt(startingTime.substring(12, 14));
        int endHours = Integer.parseInt(endingTime.substring(12, 14));
        return endHours - startHours;
    }

    /**
     * Calculate the day difference between the end and the start
     * 
     * @param startingTime
     * @param endingTime
     * @return the day difference
     */
    private static int daysOfTheEvent(String startingTime, String endingTime) {
        int startDate = Integer.parseInt(startingTime.substring(4, 6));
        int endDate = Integer.parseInt(endingTime.substring(4, 6));
        return endDate - startDate;
    }

    /**
     * Calculate the year difference between the end and the start
     * 
     * @param startingTime
     * @param endingTime
     * @return the day difference
     */
    private static int yearsOfTheEvent(String startingTime, String endingTime) {
        int startYear = Integer.parseInt(startingTime.substring(7, 11));
        int endYear = Integer.parseInt(endingTime.substring(7, 11));
        return endYear - startYear;
    }

    /**
     * Calculate the month difference between the end and the start
     * 
     * @param startingTime
     * @param endingTime
     * @return the month difference
     */
    private static int monthsOfTheEvent(String startingTime, String endingTime) {
        String startMonth = startingTime.substring(0, 3);
        String endMonth = endingTime.substring(0, 3);
        int monthDifference = whatMonth(endMonth) - whatMonth(startMonth);
        return monthDifference;
    }

    @Override
    public String toString() {
        return setTime;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof DateTimeInfo // instanceof handles nulls
                        && this.setTime.equals(((DateTimeInfo) other).setTime)); // state check
    }

    @Override
    public int hashCode() {
        return setTime.hashCode();
    }

    /**
     * @return true if the date not specified; 
     */
    public boolean isDateNull() {
        return this.setTime.equals("Feb 29 2000 00:00");
    }

    /**
     * If the time is inferred, replace "07:59" with "16:59" 
     */
    public void isEndTimeInferred() {
        if (setTime.substring(12, 17).equals("07:59")) {
            setTime = setTime.substring(0, 12) + "16:59";
        }
    }

    /**
     * Process the task if the task is in the future
     * @param timeNow
     * @param Date
     * @return true if the timing timeNow is after the timing Date
     */
    public static boolean isInTheFuture(DateTimeInfo timeNow, DateTimeInfo Date) {
        String result = MESSAGE_FROM_IS_AFTER_TO;
        result = durationBetweenTwoTiming(timeNow.toString(),Date.toString());
        return !result.equals(MESSAGE_FROM_IS_AFTER_TO);
    }

    /**
     * Process the task if the task is in the past
     * @param timeNow
     * @param Date
     * @return true if the timing timeNow is before the timing Date
     */
    public static boolean isInThePast(DateTimeInfo timeNow, DateTimeInfo Date) {
        return isInTheFuture(Date,timeNow);
    }
    
    /**
     * Prepare the keyword and process if the task is within the specified date. 
     * @param keyWords
     * @param task
     * @return 
     */
    public static boolean isOnTheDate(String dateInfo, ReadOnlyTask task) {
        try {
            dateInfo = new DateTimeInfo (dateInfo).toString().substring(0,11);
        } catch (IllegalValueException e) {
            new IllegalValueException (MESSAGE_DATETIMEINFO_CONSTRAINTS);
        }
        return isTaskOnTheSpecifiedDate(task, dateInfo);
    }

    /**
     * Process if the task given has any relation with the dateInfo. 
     * For a task relation is defined as the due date is the dateInfo date. 
     * For an event, the event duration (inclusive the starting and the ending date) is within the specified  DateInfo date. 
     * @param task
     * @param dateInfo
     * @return true if the task has anything to do with the day of interest
     */
    private static boolean isTaskOnTheSpecifiedDate(ReadOnlyTask task, String dateInfo) {
        return task.getDueDate().toString().contains(dateInfo) || task.getEndTime().toString().contains(dateInfo) 
                || task.getStartTime().toString().contains(dateInfo) 
                || isTaskAnEventPassingThisDate(task, dateInfo);
    }

    /**
     * Process the data if it the task is a event and it is passing through the date specified.
     * @param task
     * @param dateInfo
     * @return true if a task is an event and the day interest is within the starting date and the ending date 
     */
    private static boolean isTaskAnEventPassingThisDate(ReadOnlyTask task, String dateInfo) {
        if (!task.getIsEvent()){
            return false; 
        } 
        DateTimeInfo dateSpecified;
        try {
            dateSpecified = new DateTimeInfo (dateInfo);
            return isInTheFuture(task.getStartTime(), dateSpecified) && isInTheFuture(dateSpecified, task.getEndTime()); 
        } catch (IllegalValueException e) {
            new IllegalValueException (MESSAGE_DATETIMEINFO_CONSTRAINTS);
        }
        return FAIL_DUE_TO_EXCEPTION; 
    }

    /** 
     * Process if the a task specified is with in the duration stated.
     * @param keyWords
     * @param task
     * @return true if the date is within the duration 
     */
    public static boolean withInTheDuration(String keyWords, ReadOnlyTask task, String dateNow) {
        boolean isWithInTime = false; 
        if ( keyWords.contains(ListCommand.LIST_LAST_WEEK_COMMAND) ){
            return isNotFloatingTaskAndWithinTheTime(task, dateNow, -DAYS_IN_A_WEEK);
        } else if ( keyWords.contains(ListCommand.LIST_LAST_MONTH_COMMAND) ){
            return isNotFloatingTaskAndWithinTheTime(task, dateNow, -AVERAGE_DAYS_IN_A_MONTH);
        } else if ( keyWords.contains(ListCommand.LIST_NEXT_MONTH_COMMAND) ){
            return isNotFloatingTaskAndWithinTheTime(task, dateNow, AVERAGE_DAYS_IN_A_MONTH);
        } else if ( keyWords.contains(ListCommand.LIST_NEXT_WEEK_COMMAND) ){
            return isNotFloatingTaskAndWithinTheTime(task, dateNow, DAYS_IN_A_WEEK);
        }        
        return isWithInTime;
    }

    /**
     * Process if the task given is either a deadline task or an event within the specified timing
     * @param task
     * @param dateNow
     * @param expectedDays 
     * @return true if the task is not a floating task and it is within the specified timing
     */
    private static boolean isNotFloatingTaskAndWithinTheTime(ReadOnlyTask task, String dateNow, int expectedDays) {
        if (task.getIsNotFloatingTask()){
            return isTaskWithInTheDuration(task, dateNow, expectedDays); 
        } else { 
            return false; 
        }
    }

    /**
     * Process if a deadline task or an event is within the duration specified.
     * @param task
     * @param dateNow
     * @param expectedDays
     * @return true if the task is within the stated duration 
     */
    private static boolean isTaskWithInTheDuration(ReadOnlyTask task, String dateNow, int expectedDays) {
        boolean isTimeWithinExpectedTime=false;
        if (task.getIsNotFloatingTask()){
            isTimeWithinExpectedTime = isTimeDifferenceLessThanSpecified(dateNow, 
                    task.getStartingTimeOrDueDate().toString(), expectedDays);
        }
        return isTimeWithinExpectedTime;
    }
    
    /**
     * Provide an easy access to the current timing in String 
     * @return String of the current time MMM DD YYYY HH:MM format. 
     */
    public static DateTimeInfo getCurrentTimeInString() {
        DateTimeInfo dateNow = null;
        try {
            dateNow = new DateTimeInfo ("now");
        } catch (IllegalValueException e) {
            new IllegalValueException (MESSAGE_DATETIMEINFO_CONSTRAINTS);
        }
        return dateNow;
    }

    /**
     * Process if the two given time is less than the time duration.
     * @param startTime 
     * @param endTime 
     * @param limitTimeDuration 
     * @return  true if the time Difference is less than specified
     */
    private static boolean isTimeDifferenceLessThanSpecified(String startTime, String endTime, int limitTimeDuration) {
        if (limitTimeDuration<0){
            limitTimeDuration = limitTimeDuration*(-1);  
            return isTimeDifferenceLessThanSpecified (endTime, startTime, limitTimeDuration);
        }

        int years = yearsOfTheEvent(startTime, endTime);
        int months = monthsOfTheEvent(startTime, endTime);
        int days = daysOfTheEvent(startTime, endTime);
        int hours = hoursOfTheEvent(startTime, endTime);

        if (hours < 0) {
            hours = Math.floorMod(hours, 24);
            days=days-1;
        } 
        if (days < 0) {
            days = Math.floorMod(days, 30);
            months=months-1;
        }
        if (months < 0 || months>1) {
            return false; 
        }
        if (years < 0 || years > 0) {
            return false;
        } 
        if(days <= limitTimeDuration && months==0){
            return true; 
        } else if ( limitTimeDuration==AVERAGE_DAYS_IN_A_MONTH && months==1){
            return true; 
        } else {
            return false; 
        }
    }

    @Override
    public int compareTo(DateTimeInfo dateTimeInfo2) {
        Date dateObject1 = convertToDateObject(this.setTime);
        Date dateObject2 = convertToDateObject(dateTimeInfo2.setTime);
        return dateObject1.compareTo(dateObject2);
    }
    
    private Date convertToDateObject(String dateString){
        try{
            DateTimeInfoParser parsedTiming = new DateTimeInfoParser(dateString);
            return parsedTiming.getParsedTimingObject().get(0);
        }catch(IllegalValueException ive){
            return null;
        }
        
    }
    
}
```
###### /java/seedu/flexitrack/model/task/DateTimeInfoParser.java
``` java
/**
 * Represents the Parser and Time related DateTimeInfo.
 */
public class DateTimeInfoParser {

    public static final String MESSAGE_DATETIMEINFO_CONSTRAINTS = "Invalid time inputed. Please check your spelling!";

    private DateGroup timingInfo;

    public DateTimeInfoParser(String givenTime) throws IllegalValueException {
        try {
            Parser parser = new Parser();
            List<DateGroup> dateParser = parser.parse(givenTime);
            setTimingInfo(dateParser);
        } catch (IndexOutOfBoundsException e) {
            throw new IllegalValueException(MESSAGE_DATETIMEINFO_CONSTRAINTS);
        }
    }

    /**
     * Set the timingInfo variable with the time specified
     * 
     * @param dateParser
     */
    private void setTimingInfo(List<DateGroup> dateParser) {
        this.timingInfo = dateParser.get(0);
    }

    public String getParsedTimingInfo() {
        return timingInfo.getDates().toString();
    }
    
```
###### /java/seedu/flexitrack/model/task/Name.java
``` java
    @Override
    public String toString(){ 
        return isDonePrefix + fullName; 
    }

    public String getNameOnly(){ 
        return fullName; 
    }

    public String setAsMark(){ 
        return isDonePrefix = DONE_PREFIX; 
    }

    public String setAsUnmark(){ 
        return isDonePrefix = ""; 
    }
}
```
###### /java/seedu/flexitrack/model/task/Task.java
``` java
    public boolean getIsNotFloatingTask(){
        return (this.isEvent || this.isTask);
    }
    
    public DateTimeInfo getStartingTimeOrDueDate(){
        if (this.getIsTask()){
            return this.getDueDate();
        } else {
            return  this.getStartTime();
        }
    }
    
    public DateTimeInfo getEndingTimeOrDueDate(){
        if (this.getIsTask()){
            return this.getDueDate();
        } else {
            return  this.getEndTime();
        }
    }
    
}
```
